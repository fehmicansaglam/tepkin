{"name":"Tepkin","tagline":"Reactive MongoDB Driver for Scala and Java 8","body":"[![Join the chat at https://gitter.im/fehmicansaglam/tepkin](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/fehmicansaglam/tepkin?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\n[![Build Status](https://travis-ci.org/fehmicansaglam/tepkin.svg?branch=master)](https://travis-ci.org/fehmicansaglam/tepkin)\r\n[![Codacy Badge](https://www.codacy.com/project/badge/d5039668605d44fea3adf2302e7e6c31)](https://www.codacy.com/public/fehmicansaglam/tepkin)\r\n![Progress](http://progressed.io/bar/0?title=0.2)\r\n\r\nReactive MongoDB Driver for Scala 2.11 and Java 8 built on top of Akka IO and Akka Streams.\r\n\r\nOnly MongoDB 2.6+ is supported.\r\n\r\nDon't hesitate to ask questions in the [Tepkin Google Group](https://groups.google.com/forum/#!forum/tepkin)\r\n\r\n## Contributions\r\nTepkin is a young but very active project and absolutely needs your help. Good ways to contribute include:\r\n\r\n* Raising bugs and feature requests\r\n* Fixing bugs\r\n* Improving the performance\r\n* Adding to the documentation\r\n\r\nPlease read our Scala Guide first: https://github.com/fehmicansaglam/tepkin/wiki/Scala-Guide\r\n\r\n## Quick Start\r\n\r\n### Setting up dependencies\r\n\r\nLatest stable Tepkin release is **0.1** and is available on [Maven Central](http://search.maven.org/#search%7Cga%7C1%7Ctepkin).\r\n\r\nScala developers, add the following dependency:\r\n\r\n```scala\r\nlibraryDependencies ++= Seq(\r\n  \"net.fehmicansaglam\" %% \"tepkin\" % \"0.1\"\r\n)\r\n```\r\n\r\nJava developers, `net.fehmicansaglam.tepkin.api` package is intended to be used from Java. To use the package, add the following dependency to your pom.xml:\r\n\r\n```xml\r\n<dependency>\r\n  <groupId>net.fehmicansaglam</groupId>\r\n  <artifactId>tepkin-java_2.11</artifactId>\r\n  <version>0.1</version>\r\n</dependency>\r\n```\r\n\r\nOr if you want to be on the bleeding edge using snapshots, latest snapshot release is **0.2-SNAPSHOT**.\r\n\r\nScala developers, add the following repository and dependency:\r\n```scala\r\nresolvers += \"Sonatype Snapshots\" at \"https://oss.sonatype.org/content/repositories/snapshots/\"\r\n\r\nlibraryDependencies ++= Seq(\r\n  \"net.fehmicansaglam\" %% \"tepkin\" % \"0.2-SNAPSHOT\"\r\n)\r\n```\r\n\r\nJava developers add the following repository and dependency to your pom.xml:\r\n\r\n```xml\r\n<repository>\r\n  <id>Sonatype Snapshots</id>\r\n  <url>https://oss.sonatype.org/content/repositories/snapshots/</url>\r\n</repository>\r\n\r\n<dependency>\r\n\t<groupId>net.fehmicansaglam</groupId>\r\n\t<artifactId>tepkin-java_2.11</artifactId>\r\n\t<version>0.2-SNAPSHOT</version>\r\n</dependency>\r\n```\r\n\r\n## Scala API\r\n\r\n### Working with BSON DSL\r\n\r\nTo construct a Bson document, you can either create BsonElements and join them with `~` or create a document directly.\r\n\r\n```scala\r\nimport net.fehmicansaglam.bson.BsonDsl._\r\nimport net.fehmicansaglam.bson.Implicits._\r\nimport net.fehmicansaglam.bson.element.BsonObjectId\r\nimport org.joda.time.DateTime\r\n\r\n// Construct a BsonDocument from BsonElements\r\nval element = \"name\" := \"Johny\"\r\nval document = element ~\r\n  (\"surname\" := \"Doe\") ~\r\n  (\"age\" := 28) ~\r\n  (\"months\" := $array(1, 2, 3))\r\n\r\n// Construct a BsonDocument\r\nval document = $document(\r\n  \"_id\" := BsonObjectId.generate,\r\n  \"name\" := \"Johny\",\r\n  \"surname\" := \"Doe\",\r\n  \"age\" := 28,\r\n  \"months\" := $array(1, 2, 3),\r\n  \"details\" := $document(\r\n    \"salary\" := 455.5,\r\n    \"inventory\" := $array(\"a\", 3.5, 1L, true),\r\n    \"birthday\" := new DateTime(1987, 3, 5, 0, 0)\r\n  )\r\n)\r\n```\r\n\r\nThere is an implicit conversion from any `BsonElement` to `BsonDocument` for convenience.\r\n\r\n```scala\r\nimport net.fehmicansaglam.bson.BsonDocument\r\nimport net.fehmicansaglam.bson.element.BsonElement\r\nimport net.fehmicansaglam.bson.BsonDsl._\r\nimport net.fehmicansaglam.bson.Implicits._\r\n\r\nval element: BsonElement = \"name\" := \"fehmi\"\r\nval document: BsonDocument = \"name\" := \"fehmi\"\r\n```\r\n\r\n### Connecting to MongoDB\r\n\r\nTo make a connection to MongoDB, use the `MongoClient` interface.\r\n\r\n```scala\r\nimport net.fehmicansaglam.tepkin.MongoClient\r\n\r\n// Connect to a MongoDB node.\r\nval client = MongoClient(\"mongodb://localhost\")\r\n```\r\n\r\n`MongoClient` manages multiple connection pools to MongoDB instances and therefore is a heavy class. Most of the time you will need only one `MongoClient` instance per application.\r\n\r\nUse `MongoDatabase` and `MongoCollection` in order to obtain a reference to a database and a collection.\r\n\r\n```scala\r\n// Obtain a reference to the \"tepkin\" database\r\nval db = client(\"tepkin\")\r\n\r\n// Obtain a reference to the \"example\" collection in \"tepkin\" database.\r\nval collection = db(\"example\")\r\n```\r\n\r\n`MongoDatabase` and `MongoCollection` are lightweight classes and may be instantiated more than once if needed. However they are both immutable and reusable.\r\n\r\nAll methods in the `MongoCollection` class need an implicit `scala.concurrent.ExecutionContext` and an `akka.util.Timeout`. You can define a default timeout and use the client's execution context as shown below:\r\n\r\n```scala\r\nimport akka.util.Timeout\r\nimport scala.concurrent.duration._\r\n\r\n// val client = ...\r\n\r\nimport client.ec\r\nimplicit val timeout: Timeout = 5.seconds\r\n```\r\n\r\n### Find documents\r\n\r\n```scala\r\nimport net.fehmicansaglam.bson.BsonDocument\r\nimport net.fehmicansaglam.bson.BsonDsl._\r\nimport net.fehmicansaglam.bson.Implicits._\r\n\r\nval query: BsonDocument = \"name\" := \"fehmi\"\r\n\r\nval source = collection.find(query)\r\n```\r\n\r\nAll find methods in Tepkin return an `akka.stream.scaladsl.Source[List[BsonDocument], ActorRef]`. Then you can use any method in Akka Streams to process the returned stream.\r\n\r\n### Insert operations\r\n\r\n#### Insert a single document\r\n\r\n```scala\r\nimport net.fehmicansaglam.bson.BsonDsl._\r\nimport net.fehmicansaglam.bson.Implicits._\r\n\r\nval document = (\"name\" := \"fehmi\") ~ (\"surname\" := \"saglam\")\r\ncollection.insert(document)\r\n```\r\n#### Insert a collection of documents\r\n\r\n```scala\r\nimport net.fehmicansaglam.bson.BsonDsl._\r\nimport net.fehmicansaglam.bson.Implicits._\r\n\r\nval documents = (1 to 100).map(i => $document(\"name\" := s\"fehmi$i\"))\r\ncollection.insert(documents)\r\n```\r\n#### Insert a large number of documents from a stream\r\n\r\n```scala\r\nimport akka.stream.ActorFlowMaterializer\r\nimport akka.stream.scaladsl.Source\r\nimport net.fehmicansaglam.bson.BsonDocument\r\nimport net.fehmicansaglam.bson.BsonDsl._\r\nimport net.fehmicansaglam.bson.Implicits._\r\n\r\nimport scala.collection.immutable.Iterable\r\n\r\nimplicit val mat = ActorFlowMaterializer()(client.context)\r\n\r\nval documents: Source[List[BsonDocument], Unit] = Source {\r\n  Iterable.tabulate(100) { _ =>\r\n    (1 to 1000).map(i => $document(\"name\" := s\"fehmi$i\")).toList\r\n  }\r\n}\r\n\r\ncollection.insertFromSource(documents).runForeach(_ => ())\r\n```\r\n### Other queries\r\n\r\n#### Update\r\n\r\n```scala\r\nimport net.fehmicansaglam.bson.BsonDsl._\r\nimport net.fehmicansaglam.bson.Implicits._\r\n\r\nimport scala.concurrent.Future\r\n\r\nval document = (\"name\" := \"fehmi\") ~ (\"surname\" := \"saglam\")\r\n\r\nval result: Future[UpdateResult] = for {\r\n  insert <- collection.insert(document)\r\n  update <- collection.update(\r\n    query = \"name\" := \"fehmi\",\r\n    update = $set(\"name\" := \"fehmi can\")\r\n  )\r\n} yield update\r\n```\r\n\r\n#### Find and update\r\n\r\nUpdate and return the old document.\r\n\r\n```scala\r\nimport net.fehmicansaglam.bson.BsonDsl._\r\nimport net.fehmicansaglam.bson.Implicits._\r\n\r\ncollection.findAndUpdate(\r\n  query = Some(\"name\" := \"fehmi\"),\r\n  update = $set(\"name\" := \"fehmi can\")\r\n)\r\n```\r\n\r\nUpdate and return the updated document.\r\n\r\n```scala\r\nimport net.fehmicansaglam.bson.BsonDsl._\r\nimport net.fehmicansaglam.bson.Implicits._\r\n\r\ncollection.findAndUpdate(\r\n  query = Some(\"name\" := \"fehmi\"),\r\n  update = $set(\"name\" := \"fehmi can\"),\r\n  returnNew = true\r\n)\r\n```\r\n\r\n#### Create index\r\n```scala\r\nimport net.fehmicansaglam.bson.BsonDsl._\r\nimport net.fehmicansaglam.bson.Implicits._\r\nimport net.fehmicansaglam.tepkin.protocol.command.Index\r\n\r\ncollection.createIndexes(Index(name = \"name_surname\", key = (\"name\" := 1) ~ (\"surname\" := 1)))\r\n```\r\n\r\n## Java API\r\n\r\n```java\r\nimport net.fehmicansaglam.tepkin.api.*;\r\n\r\nMongoClient mongoClient = MongoClient.create(\"mongodb://localhost\");\r\nMongoCollection collection = mongoClient.db(\"tepkin\").collection(\"test\");\r\n\r\nBsonDocument document = BsonDocumentBuilder.create().addString(\"name\", \"fehmi\").build();\r\n\r\nFiniteDuration timeout = Duration.create(5, TimeUnit.SECONDS);\r\n\r\nCompletableFuture<Optional<BsonDocument>> cf = collection\r\n  .insert(document, mongoClient.ec(), timeout)\r\n  .thenCompose(insert -> collection.findOne(mongoClient.ec(), timeout));\r\nOptional<BsonDocument> actual = cf.get(5, TimeUnit.SECONDS);\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}